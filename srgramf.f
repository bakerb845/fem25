        !program srgramf
        subroutine srgramf(nfreq,lpratt,lbin, nzpts,nxpts, ievtime,ssec,
     ;                     tmpdir,rayfl,lovfl, minmod,maxmod, lfiles,
     ;                     slat,slon,sdepin,
     ;                     strike,dip,rake,smom,t0,
     ;                     ievid,xlatmin,xlonmin,xlatmax,xlonmax,
     ;                     myid,xdists,azims,freq,
     ;                     mxpts,uspec,vspec,wspec, ierr)
c
c
c       In this version, we allow the user to specify the moment tensor rather
c       than the strike/dip/rake of the source so we can use explosive sources.
c       The rule is that if any of the 6 moment tensor elements is not zero, then
c       we take us the moment tensor rather than the strike/dip/rake to recover the
c       source mechanism
c
c       This is a modification of srgram.f that uses only the frequencies
c       needed without going through two ffts
c
c       Comments from srgram.f:
c
c       This is a modification of the program gram.f to recover surface
c       wave greens function generated by the program earth.f. 
c
c       Orginal comments from gram.f:   
c       Surface wave greens function program
c       to be used with a moment tensor as specified for normal modes.
c       greens functions are computed for a step function source with
c       scalar moment equal to 10x27 dyne-cms.
c       greens functions will be output
c
c       This version uses a constant station location, and computes aziumth
c       and distance from that point.   This is because in 2.5D all azimuths
c       should be more or less the same.  Variable is read in grlat, grlon.
c
c       We do it this way:   put in the end member (in the X direction) stations and compute 
c       (distmin, distmax) and (azmin, azmax).   Take the event azimuth
c       to be (azmin+azmax)/2 and the distance increment to be (distmax-distmin)/(nx-1)
c

        implicit real*8 (a-h,o-z)
        implicit integer*4(i-n)

        character(*), intent(in) :: rayfl, lovfl, tmpdir
        real*8, intent(in) :: freq(nfreq), xdists(nxpts),azims(nxpts),
     ;                     slat,slon,sdepin,strike,dip,rake,smom,ssec,
     ;                     xlatmin,xlonmin,xlatmax,xlonmax,t0
        integer*4, intent(in) :: ievtime(4), nzpts,nxpts,nfreq,
     ;                           maxmod,minmod, ievid, myid
        logical*4, intent(in) :: lpratt,lbin, lfiles
        complex*16, intent(out) :: uspec(mxpts,*), vspec(mxpts,*),
     ;                             wspec(mxpts,*)
        integer*4, intent(out) :: ierr
        include 'sizes.inc'
        include 'commons.inc'
        !include 'units.inc'
       integer*4 iinf1,iinf2,iinf3,iinf4,iinf5
           parameter (iinf1=15,iinf2=16,iinf3=19,iinf4=21,iinf5=23)
       integer*4 iouf1,iouf2,iouf3,iouf4
           parameter (iouf1=17,iouf2=18,iouf3=20,iouf4=22)


c--mustf is the number of files that must be attached; see the files array below.
        parameter (mustf = 2)

        parameter (MAXX=580, MAXFREQ=400)
          
        real*8 c1,c2,s1,s2!,caz,saz

        real*8 slatr, slato, slono, delt
        real*8 slatd, slond
        !real*8 grlat, grlon
        real*8 glatmin, glatmax
        real*8 glonmin, glonmax

        real*8 glat !, glatinv
        real*8 kmperdeg
        real*8 pi

        common/strain/strn(lgrm,9)
        !dimension seis(lgrm)
        common/pitsa/selev,xphy,xdist
        !character ko*1,sfx*3,stacode*4
        !character(3) cmp(9)
        !character(2) chan(9)

        !character*132   pval
        !character*132   varname
        !character*132   parval
        character(132)   rayfile, lovfile
        character(80)    gramfl
        character(5)     cid
        !character*132   aline
        character(132)   outspec
        character(16)    gridpt
        character(11)    evdate

        integer*4 lunini
        integer*4 evid
        integer*4 modeused

        logical makesac
        !complex spec(MAXFREQ, 3, MAXX)
        complex*16, allocatable :: spec(:,:,:)
        complex*16 cfact, ctform
        !real freq(MAXFREQ)
        !real trace(2048)
        real*8 tform, omega, trec, time

c---system time
        character(8)  date
        character(10) systime
        character(5)  zone
        integer values(8)

        parameter(rad=57.29577951308232d0)
        !data cmp(1),cmp(2),cmp(3)/'err','epp','ezz'/
        !data cmp(4),cmp(5),cmp(6)/'epz','erz','erp'/
        !data cmp(7),cmp(8),cmp(9)/'vrt','rad','trn'/
        !data chan(1),chan(2),chan(3)/'rr','pp','zz'/
        !data chan(4),chan(5),chan(6)/'pz','rz','rp'/
        !data chan(7),chan(8),chan(9)/'v ','r ','t '/

        data degrad /0.017453292519943295d0/ 
        data hpi /1.5707963267948966d0/
        data pi /3.141592653589793d0/

        parameter(kmperdeg=111.069365447154d0)

        parameter(makesac = .false.) !no SAC file output

c---Initial variables:
c---mdmin & mdmx are min. & max. modes to include in the synthetic
        ierr = 0

c---these should be optional
c       makesac is true for output of sac time series
        !makesac = .FALSE.
c       makesac = .TRUE.
c       ivel is 1 for velocity output, -1 for displacement
c       for now we hardwire to displacement
        ivel = -1
c-----  date and time
c---date and time of start time
        ss = 40.d00
c       ss = 80.00
c---to is the start time
        to = 40.d0
c       to = 160.
c       to = 1000.
        

        lunini = 12
        rayfile(1:132) = ' ' 
        lovfile(1:132) = ' ' 
        rayfile = trim(adjustl(rayfl))
        lovfile = trim(adjustl(lovfl))
        rayfile = adjustl(rayfile)
        lovfile = adjustl(lovfile) 
c       open(lunini,file="srgram.specs",status='old')

c       do i = 1, mustf
c         call getvars(files(i), pval, lunini, len, ierr)
c         if (ierr.eq.1) go to 51
c         if (i.eq.1) then
c           read(pval(1:len),'(a)') lovfile
c           lenf1 = len
c         endif
c         if (i.eq.2) then
c           read(pval(1:len),'(a)') rayfile
c           lenf2 = len
c         endif
c       enddo

c---user defined options

        mdmin = minmod  !min mode
        mdmx  = maxmod  !max mode
        if (nfreq.gt.1) then !frequency interval
           df = freq(2) - freq(1)
        else
           df = freq(1)
        endif
        d0  = sdepin   !source depth
        sig = strike   !source strike
        del = dip      !source dip
        gam = rake     !source rake
        smoment = smom !source magnitude
        nom = nfreq    !number of frequencies
        nz = nzpts     !z grid point for bookkeeping
        nx = nxpts     !number of x points corresponding to this z
        slatd = slat   !source latitude
        slond = slon   !source longitude
        glatmin = xlatmin !min latitude of model
        glonmin = xlonmin !min longitude of model
        glatmax = xlatmax !max latitude of model
        glonmax = xlonmax !max longitude of model
        evid = ievid  !event id number
        jy = ievtime(1)  !source year
        jd = ievtime(2)  !source julian day
        jh = ievtime(3)  !source hour
        jm = ievtime(4)  !source minute
        sec = ssec       !source second
        to = t0          !offset time

        iy = jy
        id = jd
        ihr = jh
        im = jm
        ss = 40.d0

        allocate(spec(nfreq,3,nx))  

c----construct the frequency table
c       do i = 1, nom
c         freq(i) = df*i
c       enddo

c--the sol array is the moment tensor (mzz mxx myy mxz myz mxy); we call udc to
c--fill up from sig, del, gam if the moment tensor was not specified.
        !sol(1) = mzz
        !sol(2) = mxx
        !sol(3) = myy
        !sol(4) = mxz
        !sol(5) = myz
        !sol(6) = mxy
        call udc (sig, del, gam, sol)
        !iflag = 0
        !do i = 1, 6
        !  if (sol(i).ne.0.d0) iflag = 1
        !enddo
        !if (iflag.eq.0) call udc (sig, del, gam, sol)

        fmom = smoment*1d-27

        write(evdate,'(i4,i3,2i2)') jy, jd, jh, jm
        do i = 1, 11
          if (evdate(i:i).eq.' ') evdate(i:i) = '0'
        enddo

c----output current choices
        lunlog = 8
        gramfl(1:80) = ' '
        cid(1:5) = ' '
        write(cid,'(i5)') myid
        cid = adjustl(cid)
        gramfl = trim(adjustl(tmpdir))//'srgramf-'//trim(cid)//'.log'
        gramfl = adjustl(gramfl)
        !inquire(file=trim(gramfl),exist=ex)
        open (lunlog, file=trim(gramfl))
        call date_and_time(date, systime, zone, values)
        write(lunlog,*) ''
        write(lunlog,*) ''
        write(lunlog,*) '**********************************************'
        write(lunlog,*) '          ********* Starting SRGRAMF  ********'
        write(lunlog,*) 'Date: ', date,' Time: ', systime
        write(lunlog,*) ''

        write(lunlog,*) ' Number of X grid points :       ', nx
        write(lunlog,*) ' Reference Z grid point  :       ', nz
        !if (iflag.eq.0) then
          write(lunlog,*) ' Strike of source (degrees): ', sig
          write(lunlog,*) ' Dip of source (degrees):,   ', del
          write(lunlog,*) ' Rake of source (degrees):   ', gam
        !endif
        write(lunlog,*) ' Offset start time (to):     ', to
        write(lunlog,*) ' Moment (dynes-cm):          ', smoment
        write(lunlog,*) ' Moment tensor :             '
        write(lunlog,'(3f10.4)')  sol(2), sol(6), sol(4)
        write(lunlog,'(3f10.4)')  sol(6), sol(3), sol(5)
        write(lunlog,'(3f10.4)')  sol(4), sol(5), sol(1)
        write(lunlog,*) ' Event Identifier:           ', evid
        write(lunlog,*) ' Event date:                 ', evdate
        write(lunlog,*) ' Source Latitude:            ', slatd
        write(lunlog,*) ' Source Longitude:           ', slond
        write(lunlog,*) ' Depth of source in km:      ', d0
        write(lunlog,*) ' Xmin Receiver Latitude:     ', glatmin
        write(lunlog,*) ' Xmin Receiver Longitude:    ', glonmin
        write(lunlog,*) ' Xmax Receiver Latitude:     ', glatmax
        write(lunlog,*) ' Xmax Receiver Longitude:    ', glonmax
        write(lunlog,*) ' Minimum mode number:        ', mdmin
        write(lunlog,*) ' Maximum mode number"        ', mdmx
        write(lunlog,*) ' Number of frequencies:      ', nom
        write(lunlog,*) ' Frequency interval in Hz:       ', df 
        write(lunlog,*) ' Frequency range:            ', freq(1),
     ;                                                   freq(nom)
        write(lunlog,*) ''
        write(lunlog,*) ' Rayleigh Waves Binary: ', trim(rayfile)
        write(lunlog,*) ' Love Waves Binary:     ', trim(lovfile)
!100    format(10e12.5)
        
 
        lsou = iinf2
        llove = lsou + 2
        if (lbin) then
           open(lsou, file = trim(rayfile),form='unformatted',
     ;          status='old')
           open(llove,file = trim(lovfile),form='unformatted',
     ;          status='old')
        else
           open(lsou, file = rayfile,status='old')
           open(llove,file = lovfile,status='old')
        endif

c---location of the source (lat and lon)
        slatr = slatd * degrad     
        slato = hpi - glat(slatr)
        slono = slond * degrad

!       glatmin  =  glatmin * degrad     
!       grlato =  hpi - glat(glatmin)
!       grlono =  glonmin * degrad     
!       call bjdaz2(slato, slono, grlato, grlono, delt, az1, az2, 0)
!       delt1  = delt
!       azmin  = az1
!       bazmin = az2
!       glatmax  =  glatmax * degrad     
!       grlato =  hpi - glat(glatmax)
!       grlono =  glonmax * degrad     
!       call bjdaz2(slato, slono, grlato, grlono, delt, az1, az2, 0)
!       delt2  = delt
!       azmax  = az1
!       bazmax = az2
        
!       azav  = (azmax + azmin)/2.d0
!       bazav = (bazmax + bazmin)/2.d0
!       delt  = delt2 - delt1
!       dx    = delt/dfloat(nx-1)
!       daz   = (azmax - azmin)/dfloat(nx-1)
        azav  = (azims(1) + azims(nxpts))/2.d0
        delt  = dabs(xdists(nxpts) - xdists(1))

!       delt1 = delt1 * kmperdeg / degrad
!       delt2 = delt2 * kmperdeg / degrad
!       delt  = delt  * kmperdeg / degrad
!       dx    = dx    * kmperdeg / degrad
        delt1 = xdists(1)!*kmperdeg/degrad
        delt2 = xdists(nxpts)!*kmperdeg/degrad
        delt  = dabs(delt2 - delt1)!*kmperdeg/degrad
!       dx    = dx*kmperdeg/degrad

        !write(*,*) "delt1, delt2, delt, dx = ",  delt1, delt2, delt, dx 
        !write(*,*) "azmin, azmax, azav     = ",  azmin/degrad, azmax/degrad, azav/degrad
        write(lunlog,*) ''
        write(lunlog,*) "Distance to model point 1   = ",  delt1
        write(lunlog,*) "Distance to model point nx  = ",  delt2
        write(lunlog,*) "Apparent distance in model  = ",  delt
!       write(lunlog,*) "Apparent dx                 = ",  dx
        write(lunlog,*) "Minimum Source-Station Az   = ",  azims(1)!/degrad
        write(lunlog,*) "Maximum Source-Station Az   = ",  azims(nxpts)!/degrad
        write(lunlog,*) "Average Source-Station Az   = ",  azav!/degrad
!       write(lunlog,*) "Azimuthal increment         = ",  daz/degrad
!       write(lunlog,*) "Minimum Station-Source Baz  = ",  bazmin/degrad
!       write(lunlog,*) "Maximum Station-Source Baz  = ",  bazmax/degrad
!       write(lunlog,*) "Average Station-Source Baz  = ",  bazav/degrad
        write(lunlog,*) ''

c********************
c---as a test, set the dist and az to be simple so that we can check for constant changes
c       azav = pi
c       delt1 = 284.0
c       dx = 0.76425
c********************

c--  Note: Even though we presume a constant azimuth when we compute py, 
c    it wouldn't hurt to increment the azimuth as well as the distance here -
c    the Green's functions would just be that much more accurate (partially taking
c    into account the change in radiation pattern, for example.   The effect should
c    be small in most cases, but there is no extra effort in changing it so might
c    as well do so.
c

!       phl = pi - azav

        do i = 1, nx
!         phl = pi - azav
!         azm = azmin + (i-1)*daz
!         phl = pi - azm
          phl = pi - azims(i)*degrad 

          c1 = dcos(phl)
          s1 = dsin(phl)
          c2 = c1*c1-s1*s1
          s2 = 2.d0*c1*s1

c         dist = 284.0 + (i-1)*0.76425
!         dist = delt1 + (i-1)*dx

          dist = xdists(i) 

          lsou = iinf2
          rewind (lsou)
          rewind (llove)

          modeused = 0
          call mkhomogsr(lsou,llove,c1,s1,c2,s2,modeused, .false.,lbin)
          if (modeused.eq.0) then
            write(lunlog,*) ' No Excitation of this range of modes ... '
            write(*,*)      ' No Excitation of this range of modes ... '
            go to 999
          endif

c---pick out the parts of the responce needed for modelling
c---note that we need to scale the result to account for the potential difference
c   in number of frequencies used to represent the time domain.  Original number is
c   nscan/2, current number is nom, so the scale should be nscan/(2.0*nom). 
c   Note howver that we ill be dividing by nscan anyway, so at the end we apply
c        nscan/(2.0*nom) * 1/nscan = 1/(2.0*nom)
c         scale = nscan/(2.0*nom)
c         scale = 1.0/(2.0*nom)
          sscale = 1.d0

          do nc = 1, 3
c
c  Note that the order of strn (*, [7,8,9]) is w, u, v, whereas in 
c  most WT applications it is u, v, w.  Hence we reorder the indices here.
c
            m = nc + 7
            if (m.eq.10) m = 7
            do ifreq = 1, nom
              iki = 2*(ifreq+1)
              ikr = iki - 1
c
c----We take the complex conjugate to be consistent with WT conventions
c    and multipy by df for scaling. In this case the usual transform in WT
c    will give the correct scale in the time domain.
c
c       Be careful here - the sign on strn is such that it can be convolved
c       with poles and zeros, and this appears to follow the convention of 
c       exp(-iwt) for the forward FFT (time to frequency).  
c
c       The WT convention is exp(-iwt) for freq to time; exp(iwt) for time to freq.
c       four1.f uses exp(iwt) for time to freq, which is the same as WT, and we
c       know we have to reverse four1 to make it work properly in inst. responses.
c
c       Hence, I think the line below is correct, and we should take the conjugate
c       of strn for the Green's functions.  This has been verified later by comparison
c       with results from earth/gram.
c
c       One last thing:  in the original gram the responses are mulitplied by -1, and
c       comparison with rCMT sythetics shows that this gives them the correct polarity.
c       We will multipy by -1 here for that reason, but remember that the WT code treats
c       Z positive DOWN, while this is Z positive UP, so when you use these functions
c       in the WT code remember to multiply by -1.
c
              if (lpratt) then
                 spec(ifreq,nc,i) =-dcmplx(df,0.d0)
     ;                             *dcmplx(strn(ikr, m), -strn(iki, m))
              else
                 spec(ifreq,nc,i) =-dcmplx(df,0.d0)
     ;                             *dcmplx(strn(ikr, m),  strn(iki, m))
              endif
            enddo
          enddo

c----test to recreate the time series
          itest = 0
          if (itest.eq.1) then
            iout = 90
            trec = 1.d0/df
            npts = 2*nom
            dt = trec/dfloat(npts)
            if (lpratt) then
               ftdir =-1.d0
            else
               ftdir = 1.d0
            endif
            do j = 1, npts
              time = dfloat(j-1)*dt
              !trace(j) = 0.d0
              ctform = dcmplx(0.d0,0.d0)
              do ifreq =1, nom
                omega = 2.d0 * pi * freq(ifreq)
                cfact = cdexp(dcmplx(0.d0,ftdir*omega*time))
c               cfact = cexp(cmplx(0.0,1.0)*(omega*time))
                if (dabs(omega).le.(1.0d-30)) then
                  ctform = ctform + spec(ifreq, 1, 1)
                else if (dabs(omega-pi/dt).le.1.0d-30) then !above Nyq. Freq
                  ctform = ctform + spec(ifreq, 1, 1)*cfact
                else
                  ctform = ctform 
     ;                   + dcmplx(2.d0,0.d0)*spec(ifreq, 1, 1)*cfact
                end if
              enddo
              tform = dreal(ctform)/dfloat(npts)
              write(iout,*) time, tform
            enddo
c           do j = 1, npts
c             time = real(j-1)*dt
c             iout = 90
c             write(iout,*) time, trace(j)
c           enddo
c           stop
          endif
c---end of test

        enddo

c----write out the spectral information
        nchan = 3
        if (.not.lfiles) then
           gridpt(1:16) = ' ' 
           write(gridpt,'(3i4,2i2)') evid, nz, nx, mdmin, mdmx
           do j = 1, 16
             if (gridpt(j:j).eq.' ') gridpt(j:j) = '0'
           enddo
           outspec = "grid."//gridpt//".spec"
           if (lbin) then
              open(20,file=trim(outspec),form='unformatted')
              write(20) nx, nom, nchan, evdate
              write(20) (sngl(freq(ifreq)), ifreq = 1, nom)
           else
              open(20,file=trim(outspec),status='replace')
              write(20,*) nx, nom, nchan, evdate
              write(20,*) (sngl(freq(ifreq)),ifreq=1,nom)
           endif
        endif
        do i = 1, nx
           if (.not.lfiles) then
              do nc = 1, nchan
                if (lbin) then
                   write(20) (cmplx(spec(ifreq,nc,i)), ifreq = 1, nom)
                else
                   write(20,*) (cmplx(spec(ifreq,nc,i)), ifreq = 1, nom)
                endif
              enddo
           endif
           uspec(i,1:nom) = spec(1:nom,1,i)
           vspec(i,1:nom) = spec(1:nom,2,i)
           wspec(i,1:nom) = spec(1:nom,3,i)
        enddo
        if (.not.lfiles) close(20)
        close(lsou,status='delete')
        close(llove,status='delete')

999     write(lunlog,*) '          ********* Finished SRGRAMF  ********'
        write(lunlog,*) '**********************************************'
        !close(lunlog)
        close(lunlog,status='delete')

        ierr = 0
        deallocate(spec)
        return
!
!---error section
        write(*,*)      ' Error trying to read in frequency table.'
c       write(lunlog,*) ' Error trying to read in frequency table.'
        ierr = 2
        return
        end

      subroutine udc(sig,del,gam,f)
c
c  udc computes the unit normal, unit slip and unit moment tensor
c  given strike(sig), dip(del) and slip(gam) in degrees.
c
      implicit real*8(a-h,o-z)
      dimension un(6),us(6),f(*)
      data rad/57.29577951308232d0/ 
      s=sig/rad
      d=del/rad
      g=gam/rad
      cs=dcos(s)
      ss=dsin(s)
      cd=dcos(d)
      sd=dsin(d)
      cg=dcos(g)
      sg=dsin(g)
      un(1)=cd
      un(2)=sd*ss
      un(3)=sd*cs
      us(1)=-sg*sd
      us(2)=sg*cd*ss-cg*cs
      us(3)=sg*cd*cs+cg*ss
      f(1)=2.d0*un(1)*us(1)
      f(2)=2.d0*un(2)*us(2)
      f(3)=2.d0*un(3)*us(3)
      f(4)=un(1)*us(2)+us(1)*un(2)
      f(5)=un(1)*us(3)+us(1)*un(3)
      f(6)=un(2)*us(3)+us(2)*un(3)
      return
      end

